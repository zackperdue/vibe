package parser

import (
	"fmt"

	"github.com/vibe-lang/vibe/ast"
	"github.com/vibe-lang/vibe/lexer"
)

// Parser represents a parser for the Vibe language
type Parser struct {
	l         *lexer.Lexer
	curToken  lexer.Token
	peekToken lexer.Token
	errors    []string
	seenNonRequireStmt bool // Track if we've seen non-require statements

	// Precedence table for operators (needed by expressions.go)
	precedences map[lexer.TokenType]int
}

// Define precedence levels
const (
	_ int = iota
	LOWEST
	EQUALS      // ==
	LESSGREATER // > or <
	SUM         // +
	PRODUCT     // *
	PREFIX      // -X or !X
	CALL        // myFunction(X)
	INDEX       // array[index]
	ATTRIBUTE   // obj.attr
)

// New creates a new Parser
func New(l *lexer.Lexer) *Parser {
	p := &Parser{l: l, errors: []string{}}

	// Initialize precedence table
	p.precedences = map[lexer.TokenType]int{
		lexer.EQ:       EQUALS,
		lexer.NOT_EQ:   EQUALS,
		lexer.LT:       LESSGREATER,
		lexer.GT:       LESSGREATER,
		lexer.LT_EQ:    LESSGREATER,
		lexer.GT_EQ:    LESSGREATER,
		lexer.PLUS:     SUM,
		lexer.MINUS:    SUM,
		lexer.SLASH:    PRODUCT,
		lexer.ASTERISK: PRODUCT,
		lexer.MODULO:   PRODUCT,
		lexer.LPAREN:   CALL,
		lexer.LBRACKET: INDEX,
		lexer.DOT:      ATTRIBUTE,
	}

	// Read two tokens, so curToken and peekToken are both set
	p.nextToken()
	p.nextToken()

	return p
}

// nextToken advances the parser to the next token
func (p *Parser) nextToken() {
	p.curToken = p.peekToken
	p.peekToken = p.l.NextToken()
}

// Errors returns parser errors
func (p *Parser) Errors() []string {
	return p.errors
}

// Parse parses the input and returns an AST
func Parse(l *lexer.Lexer) (*ast.Program, []string) {
	p := New(l)
	program := p.parseProgram()
	return program, p.Errors()
}

// parseProgram parses the program
func (p *Parser) parseProgram() *ast.Program {
	program := &ast.Program{
		Statements: []ast.Node{},
	}

	for !p.curTokenIs(lexer.EOF) {
		stmt := p.parseStatement()
		if stmt != nil {
			program.Statements = append(program.Statements, stmt)
		}
		p.nextToken()
	}

	return program
}

// parseStatement parses a statement
func (p *Parser) parseStatement() ast.Node {
	switch p.curToken.Type {
	case lexer.IDENT:
		// Check if this is an assignment
		if p.peekTokenIs(lexer.ASSIGN) || p.peekTokenIs(lexer.PLUS_ASSIGN) ||
		   p.peekTokenIs(lexer.MINUS_ASSIGN) || p.peekTokenIs(lexer.MUL_ASSIGN) ||
		   p.peekTokenIs(lexer.DIV_ASSIGN) || p.peekTokenIs(lexer.MOD_ASSIGN) {
			return p.parseAssignment()
		}
		// Check if this is a variable declaration with type annotation
		if p.peekTokenIs(lexer.COLON) {
			return p.parseVariableDeclaration()
		}
		return p.parseExpression(LOWEST)
	case lexer.RETURN:
		return p.parseReturnStatement()
	case lexer.PRINT:
		return p.parsePrintStatement()
	case lexer.IF:
		return p.parseIfStatement()
	case lexer.FUNCTION:
		return p.parseFunctionDefinition()
	case lexer.FOR:
		return p.parseForStatement()
	case lexer.WHILE:
		return p.parseWhileStatement()
	case lexer.REQUIRE:
		return p.parseRequireStatement()
	case lexer.CLASS:
		return p.parseClassDefinition()
	case lexer.TYPE:
		return p.parseTypeDeclaration()
	case lexer.SUPER:
		return p.parseSuperCall()
	case lexer.INT, lexer.FLOAT, lexer.STRING, lexer.TRUE, lexer.FALSE, lexer.NIL,
		lexer.LPAREN, lexer.LBRACKET, lexer.LBRACE, lexer.MINUS, lexer.BANG:
		return p.parseExpression(LOWEST)
	default:
		return nil
	}
}

// parseAssignment parses an assignment
func (p *Parser) parseAssignment() ast.Node {
	// Save the variable name
	name := p.curToken.Literal

	// Skip to the assignment operator
	p.nextToken()

	// Skip the assignment operator
	p.nextToken()

	// Parse the value
	value := p.parseExpression(0)

	return &ast.Assignment{
		Name:  name,
		Value: value,
	}
}

// parseRequireStatement parses a require statement
func (p *Parser) parseRequireStatement() ast.Node {
	// Skip 'require' keyword
	p.nextToken()

	// Parse path string
	if p.curToken.Type != lexer.STRING {
		p.addError(fmt.Sprintf("Expected string path after 'require', got %s", p.curToken.Type))
		return nil
	}

	path := p.curToken.Literal

	return &ast.RequireStmt{
		Path: path,
	}
}

// parseSuperCall parses a super call
func (p *Parser) parseSuperCall() ast.Node {
	// TODO: Implement super call parsing
	return nil
}

// Helper methods for token checking
func (p *Parser) curTokenIs(t lexer.TokenType) bool {
	return p.curToken.Type == t
}

func (p *Parser) peekTokenIs(t lexer.TokenType) bool {
	return p.peekToken.Type == t
}

func (p *Parser) expectPeek(t lexer.TokenType) bool {
	if p.peekTokenIs(t) {
		p.nextToken()
		return true
	}
	p.peekError(t)
	return false
}

// peekError adds an error when the next token is not what was expected
func (p *Parser) peekError(t lexer.TokenType) {
	msg := fmt.Sprintf("Expected next token to be %s, got %s instead at line %d, column %d",
		t, p.peekToken.Type, p.peekToken.Line, p.peekToken.Column)
	p.errors = append(p.errors, msg)
}

// addError adds an error message to the parser
func (p *Parser) addError(msg string) {
	p.errors = append(p.errors, fmt.Sprintf("%s at line %d, column %d",
		msg, p.curToken.Line, p.curToken.Column))
}

// parseReturnStatement parses a return statement
func (p *Parser) parseReturnStatement() ast.Node {
	// Skip 'return' keyword
	p.nextToken()

	// Parse the return value expression if present
	var returnValue ast.Expression
	if !p.curTokenIs(lexer.SEMICOLON) && p.curToken.Type != lexer.EOF && p.curToken.Type != lexer.RBRACE {
		returnValue = p.parseExpression(0)
	}

	// Skip optional semicolon
	if p.peekTokenIs(lexer.SEMICOLON) {
		p.nextToken()
	}

	return &ast.ReturnStmt{
		ReturnValue: returnValue,
	}
}

// parsePrintStatement parses a print statement
func (p *Parser) parsePrintStatement() ast.Node {
	// Skip 'print' keyword
	p.nextToken()

	// Parse the value to print
	value := p.parseExpression(0)

	// Skip optional semicolon
	if p.peekTokenIs(lexer.SEMICOLON) {
		p.nextToken()
	}

	return &ast.PrintStmt{
		Value: value,
	}
}

// parseExpressionStatement parses an expression statement
func (p *Parser) parseExpressionStatement() ast.Node {
	expr := p.parseExpression(0)

	// Skip optional semicolon
	if p.peekTokenIs(lexer.SEMICOLON) {
		p.nextToken()
	}

	return &ast.ExpressionStmt{
		Expression: expr,
	}
}

// parseVariableDeclaration parses a variable declaration
func (p *Parser) parseVariableDeclaration() ast.Node {
	// Parse the type
	if !p.expectPeek(lexer.COLON) {
		return nil
	}

	// Parse the variable name
	if !p.expectPeek(lexer.IDENT) {
		return nil
	}

	name := p.curToken.Literal

	// Parse the value
	value := p.parseExpression(0)

	return &ast.VariableDeclaration{
		Name:    name,
		Type:    p.curToken.Literal,
		Value:   value,
		Line:    p.curToken.Line,
		Column:  p.curToken.Column,
	}
}

// parseIfStatement parses an if statement
func (p *Parser) parseIfStatement() ast.Node {
	// TODO: Implement if statement parsing
	return nil
}

// parseWhileStatement parses a while statement
func (p *Parser) parseWhileStatement() ast.Node {
	// TODO: Implement while statement parsing
	return nil
}

// parseForStatement parses a for statement
func (p *Parser) parseForStatement() ast.Node {
	// TODO: Implement for statement parsing
	return nil
}

// parseFunctionDefinition parses a function definition
func (p *Parser) parseFunctionDefinition() ast.Node {
	// TODO: Implement function definition parsing
	return nil
}

// parseClassDefinition parses a class definition
func (p *Parser) parseClassDefinition() ast.Node {
	// TODO: Implement class definition parsing
	return nil
}

// parseTypeDeclaration parses a type declaration
func (p *Parser) parseTypeDeclaration() ast.Node {
	// TODO: Implement type declaration parsing
	return nil
}

// parseExpression parses an expression
func (p *Parser) parseExpression(precedence int) ast.Expression {
	// TODO: Implement expression parsing
	return nil
}

// Debug helper
func debugf(format string, args ...interface{}) {
	//fmt.Printf(format+"\n", args...)
}